p8105_hw6_hmz2105
================
Haley Zylberberg

``` r
library (tidyverse)
```

    ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
    ## ✔ dplyr     1.1.3     ✔ readr     2.1.4
    ## ✔ forcats   1.0.0     ✔ stringr   1.5.0
    ## ✔ ggplot2   3.4.3     ✔ tibble    3.2.1
    ## ✔ lubridate 1.9.2     ✔ tidyr     1.3.0
    ## ✔ purrr     1.0.2     
    ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
    ## ✖ dplyr::filter() masks stats::filter()
    ## ✖ dplyr::lag()    masks stats::lag()
    ## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors

``` r
set.seed(123)
```

## Problem 2

In this problem, I will use Central Park weather data to create a simple
linear regression with tmax as the response and tmin and prcp as the
predictors. I use 5000 bootstrap samples to calculate r squared and log
(B1\*B2), and then plot the distribution of these estimates.

First pull in weather data.

``` r
weather_df = 
  rnoaa::meteo_pull_monitors(
    c("USW00094728"),
    var = c("PRCP", "TMIN", "TMAX"), 
    date_min = "2022-01-01",
    date_max = "2022-12-31") |>
  mutate(
    name = recode(id, USW00094728 = "CentralPark_NY"),
    tmin = tmin / 10,
    tmax = tmax / 10) |>
  select(name, id, everything())
```

    ## using cached file: /Users/Haley/Library/Caches/org.R-project.R/R/rnoaa/noaa_ghcnd/USW00094728.dly

    ## date created (size, mb): 2023-10-04 17:08:38.483749 (8.527)

    ## file min/max dates: 1869-01-01 / 2023-10-31

Next create a bootstrap with 5000 samples. Will create a dataframe that
retains the r squared and the log(B1\*B2) only.

``` r
boot_sample = function(df) {
  sample_frac(df, replace = TRUE)
}

boot_straps = 
  tibble(strap_number = 1:5000) |> 
  mutate(
    strap_sample = map(strap_number, \(i) boot_sample(df = weather_df))
  )

bootstrap_results =
  boot_straps |> 
  mutate(
    models = map(strap_sample, \(df) lm(tmax ~ tmin + prcp, data = df)),
    results = map(models, broom::glance),
    results2 = map(models, broom::tidy)
  ) |> 
  select(-strap_sample, -models) |> 
  unnest(results, results2) 
```

    ## Warning: `unnest()` has a new interface. See `?unnest` for details.
    ## ℹ Try `df %>% unnest(c(results, results2))`, with `mutate()` if needed.

``` r
plot = bootstrap_results |> 
  janitor::clean_names()|>
  filter(term != "(Intercept)")|>
  group_by(strap_number, r_squared) |> 
summarize(log_product = log(prod(abs(estimate))))
```

    ## `summarise()` has grouped output by 'strap_number'. You can override using the
    ## `.groups` argument.

Next will plot the distribution of r squared.

``` r
plot|>
ggplot(aes(x = r_squared)) +
    geom_density() +
  labs(title = "Distribution of R-squared",
       x = "R-squared",
       y = "Frequency") +
  theme_minimal()
```

![](p8105_hw6_hmz2105_files/figure-gfm/plot%20r%20squared-1.png)<!-- -->

- The density plot of r squared values shows the distribution of the
  goodness of fit for the linear regression models. R squared measures
  the proportion of the variability in tmax that is explained by the
  predictors tmin and prcp. In this plot, the distribution is skewed to
  the left but overall appears mostly normal. As the values are
  relatively close to 1, the model has a high goodness of fit.

Next will plot the distribution of log(B1\*B2).

``` r
plot|>
ggplot(aes(x = log_product)) +
  geom_density() +
  labs(title = "Distribution of log(B1 * B2)",
       x = "log(B1 * B2)",
       y = "Frequency") +
  theme_minimal()
```

![](p8105_hw6_hmz2105_files/figure-gfm/plot%20log-1.png)<!-- -->

- This density plot provides insights into the joint effect of the
  predictor variables (tmin and prcp) on tmax. This distribution is very
  skewed to the left. It appears that there is a joint effect between
  tmin and prcp.

Next will make a table showing the 95% confidence levels for r squared
and log (B1\*B2).

``` r
confidence_intervals <- data.frame(
  variable = c("r_squared", "log_product"),
  lower_CI = c(quantile(pull(plot, r_squared), 0.025), quantile(pull(plot, log_product), 0.025)),
  upper_CI = c(quantile(pull(plot, r_squared), 0.975), quantile(pull(plot, log_product), 0.975))
)

confidence_intervals|> 
  knitr::kable()
```

| variable    |   lower_CI |   upper_CI |
|:------------|-----------:|-----------:|
| r_squared   |  0.8882079 |  0.9402552 |
| log_product | -8.6969696 | -4.6011529 |
